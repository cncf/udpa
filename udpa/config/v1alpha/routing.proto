syntax = "proto3";

package udpa.data.orca.v1;

option java_outer_classname = "Routing";
option java_multiple_files = true;
option java_package = "com.github.udpa.udpa.config.v1alpha";
option go_package = "v1alpha";

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

import "validate/validate.proto";

message ConfigProvider {}

// A regex matcher designed for safety when used with untrusted input.
message RegexDescriptor {
  // Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex string must adhere to
  // the documented `syntax <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed
  // to complete execution in linear time as well as limit the amount of memory used.
  message GoogleRE2 {
    // This field controls the RE2 "program size" which is a rough estimate of how complex a
    // compiled regex is to evaluate. A regex that has a program size greater than the configured
    // value will fail to compile. In this case, the configured max program size can be increased
    // or the regex can be simplified. If not specified, the default is 100.
    google.protobuf.UInt32Value max_program_size = 1;
  }

  oneof engine_type {
    option (validate.required) = true;

    // Google's RE2 regex engine.
    GoogleRE2 google_re2 = 1 [(validate.rules).message.required = true];
  }
}

// Specifies the way to match a string.
message StringMatchDescriptor {
  oneof match_pattern {
    option (validate.required) = true;

    // The input string must match exactly the string specified here.
    //
    // Examples:
    //
    // * *abc* only matches the value *abc*.
    google.protobuf.Empty exact = 1;

    // The input string must have the prefix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * *abc* matches the value *abc.xyz*
    google.protobuf.Empty prefix = 2;

    // The input string must have the suffix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * *abc* matches the value *xyz.abc*
    google.protobuf.Empty suffix = 3;

    // The input string must match the regular expression specified here.
    RegexDescriptor regex = 4;
  }
}

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
message Int64Range {
  // start of the range (inclusive)
  int64 start = 1;

  // end of the range (exclusive)
  int64 end = 2;
}

// Header name/value pair.
message HeaderValue {
  // Header name.
  string key = 1 [(validate.rules).string = {min_bytes: 1, max_bytes: 16384}];

  // Header value.
  //
  // The same :ref:`format specifier <config_access_log_format>` as used for
  // :ref:`HTTP access logging <config_access_log>` applies here, however
  // unknown header values are replaced with the empty string instead of `-`.
  string value = 2 [(validate.rules).string.max_bytes = 16384];
}

// Header name/value pair plus option to control append behavior.
message HeaderValueOption {
  // Header name/value pair that this option applies to.
  HeaderValue header = 1 [(validate.rules).message.required = true];

  // Should the value be appended? If true (default), the value is appended to
  // existing values.
  google.protobuf.BoolValue append = 2;
}

// Request transformation when the action is request forwarding.
message Transform {
  // Specifies a list of HTTP headers that should be added to each response that
  // the connection manager encodes. Headers specified at this level are applied
  // after headers from any enclosed :ref:`envoy_api_msg_route.VirtualHost` or
  // :ref:`envoy_api_msg_route.RouteAction`. For more information, including details on
  // header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated HeaderValueOption response_headers_to_add = 4
      [(validate.rules).repeated .max_items = 1000];

  // Specifies a list of HTTP headers that should be removed from each response
  // that the connection manager encodes.
  repeated string response_headers_to_remove = 5;

  // Specifies a list of HTTP headers that should be added to each request
  // routed by the HTTP connection manager. Headers specified at this level are
  // applied after headers from any enclosed :ref:`envoy_api_msg_route.VirtualHost` or
  // :ref:`envoy_api_msg_route.RouteAction`. For more information, including details on
  // header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated HeaderValueOption request_headers_to_add = 6
      [(validate.rules).repeated .max_items = 1000];

  // Specifies a list of HTTP headers that should be removed from each request
  // routed by the HTTP connection manager.
  repeated string request_headers_to_remove = 8;
}

// Actions may be redirect, route (forward) or further match-action tree levels.
message Action {
  // Redirects are a copy+paste of the Envoy v2 xDS
  // envoy.api.v2.route.RedirectAction message. While this could be rewritten
  // significantly for clarity, the idea is that the behaviors here seem very
  // implementation non-specific. TODO(htuch): Can all the DPLB implementations
  // out there implement this?
  message Redirect {
    // When the scheme redirection take place, the following rules apply:
    //  1. If the source URI scheme is `http` and the port is explicitly
    //     set to `:80`, the port will be removed after the redirection
    //  2. If the source URI scheme is `https` and the port is explicitly
    //     set to `:443`, the port will be removed after the redirection
    oneof scheme_rewrite_specifier {
      // The scheme portion of the URL will be swapped with "https".
      bool https_redirect = 4;
      // The scheme portion of the URL will be swapped with this value.
      string scheme_redirect = 7;
    }
    // The host portion of the URL will be swapped with this value.
    string host_redirect = 1;
    // The port value of the URL will be swapped with this value.
    uint32 port_redirect = 8;

    oneof path_rewrite_specifier {
      // The path portion of the URL will be swapped with this value.
      string path_redirect = 2;

      // Indicates that during redirection, the matched prefix (or path)
      // should be swapped with this value. This option allows redirect URLs be dynamically created
      // based on the request.
      //
      // .. attention::
      //
      //   Pay attention to the use of trailing slashes as mentioned in
      //   :ref:`RouteAction's prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`.
      string prefix_rewrite = 5;
    }

    enum RedirectResponseCode {
      // Moved Permanently HTTP Status Code - 301.
      MOVED_PERMANENTLY = 0;

      // Found HTTP Status Code - 302.
      FOUND = 1;

      // See Other HTTP Status Code - 303.
      SEE_OTHER = 2;

      // Temporary Redirect HTTP Status Code - 307.
      TEMPORARY_REDIRECT = 3;

      // Permanent Redirect HTTP Status Code - 308.
      PERMANENT_REDIRECT = 4;
    }

    // The HTTP status code to use in the redirect response. The default response
    // code is MOVED_PERMANENTLY (301).
    RedirectResponseCode response_code = 3 [(validate.rules).enum.defined_only = true];

    // Indicates that during redirection, the query portion of the URL will
    // be removed. Default value is false.
    bool strip_query = 6;
  }

  // This is massively slimmed down from Envoy's v2 xDS
  // envoy.api.v2.route.RouteAction. The point being that perhaps the most basic
  // universal thing we can do is point at a given service. Beyond this, it's
  // going to require feature-by-feature analysis.
  message Route {
    // The service names
    string service_name = 1;

    // Request transform description, i.e. what are we doing to the request
    // when forwarding?
    Transform transform = 2;

    // TODO(htuch): what other parts of RouteAction are shared by known DPLBs?

    // DPLB specific behaviors, e.g. traffic mirroring, rate limiting, request
    // hedging, affinity, timeouts, retry policy, CORS, tracing, can be encoded here.
    google.protobuf.Any dplb_extensions = 3;
  }

  oneof action_specifier {
    Redirect redirect = 1;
    Route route = 2;
    // TODO(htuch): add DirectResponseAction
    Matcher match = 3;
  }
}

// Header matchers need to be able to reach within headers, e.g. :path or
// cookie, and extract values of interest, e.g. query parameter. A
// StringExtractor provides this capability.
message HeaderValueExtractor {
  oneof extractor_specifier {
    option (validate.required) = true;

    // Idempotent return of the header value.
    google.protobuf.Empty exact = 1;

    // The path component, i.e. anything before ?.
    google.protobuf.Empty path = 2;

    // A single query parameter.
    string query_parameter = 3;

    // TODO(htuch): should this be further generalized to support things like
    // extracting values embedded in header values with separators such as , or
    // :?
  }
}


// An ordered matcher is a hierarchical tree construct, specifying at each node a
// single match criteria.
message HierarchicalMatcher {
  message HeaderMatcher {
    // Specifies the name of the header in the request.
    string name = 1 [(validate.rules).string.min_bytes = 1];

    // How the header value is extracted for match.
    HeaderValueExtractor value_extractor = 2;

    // Match-action table for string values.
    message StringMatcher {
      // How will the string value be matched? The expected performance from an
      // optimized implementation is:
      // - exact: O(m)
      // - prefix: O(m)  [longest prefix wins]
      // - suffix: O(m)  [longest suffix wins]
      // - regex: O(n.m) [evaluated in-order]
      // where n is the number of entried in the match table and m is the length
      // of the value being looked up.
      StringMatchDescriptor match_descriptor = 1;

      message InlineTable {
        message MatchAction {
          // Value to match against header value using match_descriptor.
          string value = 1;

          // Action to take on match.
          Action action = 2;
        }
        repeated MatchAction inline_table = 1;
      }

      oneof table_specifier {
        // Inline match-action table.
        InlineTable inline_table = 2;

        // Support VHDS-like behavior, on-demand fetching of header routing
        // tables. The resource type is Action, the resource name is the string
        // value match to be used. E.g. an Action called "*-foo.com" may be
        // delivered dynamically. This can't be used with regex match
        // descriptors.
        ConfigProvider config_provider = 3;
      }
    }

    // Match-action table for integer ranges.
    message IntegerRangeMatcher {
      message IntegerRangeMatchAction {
        Int64Range range = 1;
        Action action = 2;
      }
      // Ranges must not overlap.
      repeated IntegerRangeMatchAction match_actions = 1;
    }

    oneof header_match_specifier {
      // String value match-action.
      StringMatcher string_matcher = 3;

      // Integer value match-action.
      IntegerRangeMatcher integer_range_matcher = 4;
    }
  }

  // Currently only header matchers are supported.
  oneof matcher_specifier {
    option (validate.required) = true;
    HeaderMatcher header_matcher = 1;
  }

  // Fall-thru action if no other match occurs.
  Action default_action = 2;
}

// A linear matcher provides the ability to iterate over a list of (match
// criteria, action) pairs, where the match criteria are a set of header
// matchers.
message LinearMatcher {
  message MatchAction {
    message HeaderMatcher {
      // Specifies the name of the header in the request.
      string name = 1 [(validate.rules).string.min_bytes = 1];

      // If specified, the match result will be inverted before checking.
      // Defaults to false.
      //
      // Examples:
      //
      // * The regex *\d{3}* does not match the value *1234*, so it will match
      //   when inverted.
      // * The range [-10,0) will match the value -1, so it will not match when
      //   inverted.
      bool invert_match = 2;

      // How the header value is extracted for match.
      HeaderValueExtractor value_extractor = 3;

      // Matcher for string values.
      message StringMatcher {
        StringMatchDescriptor match_descriptor = 1;
        string value = 2;
      }

      // Matcher for integer ranges.
      message IntegerRangeMatcher {
        Int64Range range = 1;
      }

      oneof header_matcher_specifier {
        option (validate.required) = true;

        StringMatcher string_matcher = 4;

        IntegerRangeMatcher integer_range_matcher = 5;
      }
    }

    // List of header matchers providing the match criteria. All HeaderMatchers
    // must match on the request; a logical AND of the HeaderMatcher results is
    // performed.
    repeated HeaderMatcher header_matchers = 1;

    // Action to take on match of all header_matchers.
    Action action = 2;
  }
  repeated MatchAction match_actions = 1;
}

message Matcher {
  oneof matcher_specifier {
    option (validate.required) = true;

    LinearMatcher linear_matcher = 1;

    HierarchicalMatcher hierarchical_matcher = 2;
  }
}

// A RouteConfiguration is a named resource in UDPA, describing a route table.
message RouteConfiguration {
  // Resource name.
  string name = 1 [(validate.rules).string.min_bytes = 1];

  // The root of the match-action tree.
  Matcher matcher = 2;
}
